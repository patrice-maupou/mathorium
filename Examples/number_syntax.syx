<?xml version="1.0" encoding="UTF-8"?>

<!--DOCTYPE syntax SYSTEM "syntax.dtd"-->

<!-- the one character string unused is mandatory and must not be used in any expression -->
<syntax xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="syntaxSchema.xsd"
        name="number_syntax">

  <!-- simple elements
    The rule identified by the key "SIMPLES" is mandatory to get the basic blocks of the expression.
  -->
  <read>
    <rule key="SIMPLES">
      <pattern><![CDATA[SQR|PGCD]]>
        <type name="cst"></type>
      </pattern>
      <pattern><![CDATA[\d+\.\d+]]>
        <type name="positive" subtypes="natural,var"></type>
      </pattern>
      <pattern><![CDATA[[mn]'*|\d+]]>
        <type name="natural" subtypes="var"></type>
      </pattern>
      <pattern><![CDATA[[abcdxyz]'*]]>
        <type name="real" subtypes="positive,integer"></type>
      </pattern>
      <pattern><![CDATA[[tuvw]]]>
          <type name="realvar" subtypes="real"></type>
      </pattern>
      <pattern><![CDATA[[ijkl]'*]]>
        <type name="integer" subtypes="natural"></type>
      </pattern>
      <pattern><![CDATA[(?!SQR)\b[A-Z]]]>
        <type name="var"></type>
      </pattern>
    </rule>    
    <!-- composites elements by decreasing priority -->    
    <rule key="PGCD" child="PGCD,a,b">
      <pattern node="PGCD"><![CDATA[PGCD\(a,b\)]]>
        <type name="natural" value="cst,natural,natural"></type>
      </pattern>
    </rule>
    <rule key="SQR" child="SQR,x">
      <pattern node="SQR"><![CDATA[SQR\(x\)]]>
        <type name="positive" value="cst,positive"></type>
      </pattern>
    </rule>
    <rule key="GROUP" child="a">
      <pattern node="ABS"><![CDATA[\|a\|]]>
        <type name="natural" value="integer"></type>
        <type name="positive" value="real"></type>
      </pattern>
      <pattern node="a"><![CDATA[\(a\)]]>
        <type name="inherit"  value="natural|integer|positive|real"></type>
      </pattern>
    </rule>
    <rule key="POW" child="a,n"><![CDATA[(?!\()]]>
      <pattern node="POW"><![CDATA[a\^n]]>
        <type name="natural" value="natural"></type>
        <type name="integer" value="integer,natural"></type>
        <type name="real" value="real"></type>
      </pattern>
    </rule>
    <rule key="PROD_FAMILY" child="a,b"><![CDATA[(?!(\(|\^))]]>
      <pattern node="MUL"><![CDATA[a[\*×]b|ab]]>
        <type name="inherit"  value="natural|integer|positive|real"></type>
      </pattern>
      <pattern node="DIV"><![CDATA[a/b]]>
        <type name="real" value="real"></type>
      </pattern>
    </rule>
    <rule key="ADD_FAMILY" child="a,b"><![CDATA[(?!(\(|\*|×|\^))]]>
      <pattern node="ADD"><![CDATA[a\+b]]>
        <type name="inherit"  value="natural|integer|positive|real"></type>
      </pattern>
      <pattern node="SUB"><![CDATA[a-b]]> 
        <type name="inherit"  value="integer|real"></type>
      </pattern>
    </rule>
  </read>
  
  <!-- règles de production d'expressions -->
  <generator name="develop">
      <variable type="real" name="realvar" list="t u v w z"></variable>
      <genrule name="init"></genrule>
      <genrule name="distribute">
        <match name="real" options="recursive=yes">
          <pattern name="real">(MUL,u:realvar,(ADD,v:realvar,w:realvar):real):real</pattern>
          <result>(ADD,(MUL,u:realvar,v:realvar):real,(MUL,u:realvar,w:realvar):real):real</result>  
        </match>  
        <result>(ADD,(MUL,u:realvar,v:realvar):real,(MUL,u:realvar,w:realvar):real):real</result>   
        <match name="real" options="recursive=yes">
          <pattern name="real">(MUL,(ADD,v:realvar,w:realvar):real,u:realvar):real</pattern>
          <result>(ADD,(MUL,v:realvar,u:realvar):real,(MUL,w:realvar,u:realvar):real):real</result>  
        </match>  
        <result>(ADD,(MUL,v:realvar,u:realvar):real,(MUL,w:realvar,u:realvar):real):real</result>   
        <match name="real" options="recursive=yes">
          <pattern name="real">(MUL,u:realvar,(SUB,v:realvar,w:realvar):real):real</pattern> 
          <result>(SUB,(MUL,u:realvar,v:realvar):real,(MUL,u:realvar,w:realvar):real):real</result>
        </match>  
        <result>(SUB,(MUL,u:realvar,v:realvar):real,(MUL,u:realvar,w:realvar):real):real</result>   
        <match name="real" options="recursive=yes">
          <pattern name="real">(MUL,(SUB,v:realvar,w:realvar):real,u:realvar):real</pattern> 
          <result>(SUB,(MUL,v:realvar,u:realvar):real,(MUL,w:realvar,u:realvar):real):real</result> 
        </match>  
        <result>(SUB,(MUL,v:realvar,u:realvar):real,(MUL,w:realvar,u:realvar):real):real</result>    
      </genrule>
      <genrule name="associative">
        <match name="real" options="recursive=yes">          
          <pattern name="real">(ADD,u:realvar,(ADD,v:realvar,w:realvar):real):real</pattern>
          <result>(ADD,(ADD,u:realvar,v:realvar):real,w:realvar):real</result>
        </match>
        <result>(ADD,(ADD,u:realvar,v:realvar):real,w:realvar):real</result>
      </genrule>
  </generator>
 
  <!-- sortie standard -->
  <write>
  <wrule child="a">
    <node name="ABS"><![CDATA[|a|]]></node>
  </wrule>
  <wrule child="a,n">
    <node name="POW"><![CDATA[a^n]]></node>
    <child replace="a->(a)" rules="MUL,DIV,ADD,SUB"></child>
    <child replace="n->(n)" rules="POW,MUL,DIV,ADD,SUB"></child>
  </wrule>
  <wrule child="a,b">
    <node name="MUL"><![CDATA[a×b]]></node>
    <node name="DIV"><![CDATA[a/b]]></node>
    <child replace="a->(a)" rules="ADD,SUB"></child>
    <child replace="b->(b)" rules="ADD,SUB,MUL,DIV"></child>
  </wrule>
  <wrule child="a,b">
    <node name="ADD"><![CDATA[a+b]]></node>
    <node name="SUB"><![CDATA[a-b]]></node>
    <child replace="b->(b)" rules="ADD,SUB"></child>
  </wrule>
  <wrule child="a,b">
    <node name="PGCD"><![CDATA[PGCD(a,b)]]></node>
  </wrule>
  <wrule child="x">
    <node name="SQR"><![CDATA[SQR(x)]]></node>
  </wrule>
</write>
</syntax>
