<?xml version="1.0" encoding="UTF-8"?>

<!--DOCTYPE syntax SYSTEM "syntax.dtd"-->

<!-- the one character string unused is mandatory and must not be used in any expression
     the regex (®_*) stands for an already found subexpression
-->
<syntax xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="syntaxSchema.xsd"
        name="number_syntax" unused="®">
   <!-- reading format -->
  <read>
  <!-- Rule identified by the key "SIMPLES" is mandatory to get the basic blocks of the expression.  -->
  <rule key="SIMPLES">
    <pattern><![CDATA[\d]]>
      <type name="digit" subtypes="cv"></type>
    </pattern>
    <pattern><![CDATA[[a-e]]]>
      <type name="nv"></type>
    </pattern>
    <pattern><![CDATA[[u-w]]]>
      <type name="cv"></type>
    </pattern>
  </rule>
  <rule child="a,b">
    <pattern node="CONCAT"><![CDATA[ab]]>
      <type name="natural" subtypes="digit,nv,cv" value="natural,digit"></type>
    </pattern>
  </rule>
  <rule child="a,b">
    <pattern node="ADD"><![CDATA[\(a\+b\)|a\+b]]>
      <type name="natural" value="natural,natural"></type>
    </pattern>
  </rule>
  <rule child="a,b">
    <pattern node="EQU"><![CDATA[a=b]]>
      <type name="equality" value="natural,natural"></type>
    </pattern>
  </rule>
</read>

  <!-- automatic generation of naturals equalities -->
  <generators name="addition_and_equality">
    <variable type="digit" name="cv" list="u v w"/> 
    <variable type="natural" name="nv" list="a b c"/>  
    <genrule name="base">
      <result>(EQU,(ADD,0:digit,0:digit):natural,0:digit):equality</result>
      <result>(EQU,(ADD,0:digit,1:digit):natural,1:digit):equality</result>
      <result>(EQU,(ADD,1:digit,1:digit):natural,2:digit):equality</result>
      <result>(EQU,(ADD,2:digit,1:digit):natural,3:digit):equality</result>
      <result>(EQU,(ADD,3:digit,1:digit):natural,4:digit):equality</result>
      <result>(EQU,(ADD,4:digit,1:digit):natural,5:digit):equality</result>
      <result>(EQU,(ADD,5:digit,1:digit):natural,6:digit):equality</result>
      <result>(EQU,(ADD,6:digit,1:digit):natural,7:digit):equality</result>
      <result>(EQU,(ADD,7:digit,1:digit):natural,8:digit):equality</result>
      <result>(EQU,(ADD,8:digit,1:digit):natural,9:digit):equality</result>
      <result>(EQU,(ADD,9:digit,1:digit):natural,(CONCAT,1:digit,0:digit):natural):equality</result>
    </genrule>
    <genrule name="unit=0-8">
      <match name="equality">
        <pattern>(EQU,(ADD,u:cv,1:digit):natural,v:cv):equality</pattern>
      </match>
      <match name="equality">
        <pattern>(EQU,(ADD,a:nv,1:digit):natural,(CONCAT,b:nv,u:cv):natural):equality</pattern>
      </match>
      <result>(EQU,(ADD,(CONCAT,b:natural,u:digit):natural,1:digit):natural,(CONCAT,b:natural,v:digit):natural):equality</result>
    </genrule>
    <genrule name="unit=9">
      <match name="equality">
        <pattern>(EQU,(ADD,a:nv,1:digit):natural,(CONCAT,b:nv,9:digit):natural):equality</pattern>
      </match>
      <match name="equality">
        <pattern>(EQU,(ADD,b:nv,1:digit):natural,c:nv):equality</pattern>
      </match>
      <result>(EQU,(ADD,(CONCAT,b:natural,9:digit):natural,1:digit):natural,(CONCAT,c:natural,0:digit):natural):equality</result>
    </genrule>
    <genrule name="add all">
      <match name="equality">
        <pattern>(EQU,(ADD,a:nv,b:nv):natural,c:nv):equality</pattern>
      </match>
      <match name="equality">
        <pattern>(EQU,(ADD,b:nv,1:digit):natural,d:nv):equality</pattern>
      </match>
      <match name="equality">
        <pattern>(EQU,(ADD,c:nv,1:digit):natural,e:nv):equality</pattern>
      </match>
      <result>(EQU,(ADD,a:natural,d:natural):natural,e:natural):equality</result>
    </genrule>
  </generators>

  <!-- printing format  -->
  <write>
    <wrule child="a,b">
      <node name="EQU"><![CDATA[a=b]]></node>
    </wrule>
    <wrule child="a,b">
      <node name="ADD"><![CDATA[a+b]]></node>
      <child replace="a->(a)" rules="ADD"></child>
      <child replace="b->(b)" rules="ADD"></child>
    </wrule>
    <wrule child="a,b">
      <node name="CONCAT"><![CDATA[ab]]></node>
    </wrule>
  </write>
</syntax>